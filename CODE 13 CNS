#include <stdio.h>

#define MOD 26

// Function to find modular inverse
int mod_inverse(int a, int m) {
    a = a % m;
    for (int x = 1; x < m; x++)
        if ((a * x) % m == 1)
            return x;
    return -1;
}

// Calculate determinant of 2x2 matrix mod 26
int determinant(int m[2][2]) {
    return (m[0][0]*m[1][1] - m[0][1]*m[1][0] + MOD) % MOD;
}

// Invert a 2x2 matrix mod 26
int invert_matrix(int m[2][2], int inv[2][2]) {
    int det = determinant(m);
    int det_inv = mod_inverse(det, MOD);

    if (det_inv == -1)
        return 0; // Not invertible

    inv[0][0] =  ( m[1][1] * det_inv) % MOD;
    inv[0][1] = (-m[0][1] * det_inv + MOD) % MOD;
    inv[1][0] = (-m[1][0] * det_inv + MOD) % MOD;
    inv[1][1] = ( m[0][0] * det_inv) % MOD;

    return 1;
}

// Multiply 2x2 matrix by 2x2 matrix mod 26
void multiply_matrices(int a[2][2], int b[2][2], int res[2][2]) {
    for (int i = 0; i < 2; i++)
        for (int j = 0; j < 2; j++)
            res[i][j] = (a[i][0]*b[0][j] + a[i][1]*b[1][j]) % MOD;
}

void print_matrix(const char *label, int m[2][2]) {
    printf("%s:\n", label);
    for (int i = 0; i < 2; i++)
        printf("| %2d %2d |\n", m[i][0], m[i][1]);
}

int char_to_int(char c) {
    return c - 'A';
}

// Main logic: recover key from plaintext-ciphertext
int main() {
    // Chosen plaintext: "HE", "LP" => H=7,E=4,L=11,P=15
    int P[2][2] = {
        {7, 11},  // H, L
        {4, 15}   // E, P
    };

    // Corresponding ciphertext: "KF", "AN" => K=10,F=5,A=0,N=13
    int C[2][2] = {
        {10, 0},  // K, A
        {5, 13}   // F, N
    };

    int P_inv[2][2], K[2][2];

    if (!invert_matrix(P, P_inv)) {
        printf("Plaintext matrix is not invertible. Cannot recover key.\n");
        return 1;
    }

    multiply_matrices(C, P_inv, K);

    print_matrix("Recovered Key Matrix", K);

    return 0;
}
